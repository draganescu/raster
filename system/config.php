<?php
// #Config class

// The config class is a singleton, like all the other classes
class config {

	// this is the normal singleton boilerplate
	// we do not have a base class because ... well not sure exactly why.
	private static $instances = array();
    protected function __construct() {}
    protected function __clone() {}
    
    // these are mainly defaults and we define them here 
    // so that we can set them later on to a new value
    public $rewrite = false;
    protected $config = array();
    static $extension = '.php';
    
    // given a parameter
    // $varname string
    static function set($varname) {
    	$config = config::instance();
    	$config->$varname = '';
    	$config->$current_assignment = $varname;
    	return $config;
    }
    
    // it sets a config value
    // returns $this
    public function to($value) {
    	$varname = $this->$current_assignment; 
    	$this->$varname = $value;
    	return $this;
    }
    
    // builds the config files array
    static function get_application_config() {
		$files = scandir(APPBASE.'config/');
		$array = array(); 
		foreach($files as $file) {
		    if(!is_dir(BASE.$file.'/') && strpos($file,'.php') !== false) {
				$app_config_files[] = $file;
			}
		}		
		return $app_config_files;
	}
	
	// loads a config file and also determines is we should load
	// an application specific config or a system config
	static function load($file) {
		if(file_exists(APPBASE.'config/'.$file.config::$extension)) {
			require_once APPBASE.'config/'.$file.config::$extension;
			return true;
		} else { 
			return false;
		}
	}
	
	// This brings altered config values at run time back to their original
	// values, best used when inside events
	function reset() {
		$application_config_files = config::get_application_config();
    	foreach ($application_config_files as $file) {
			require_once APPBASE.'config/'.$file;
    	}
    	return true;
	}
    
    // This method sets defaults and does the best possible to find
    // the current url where the app is executing.
    static function initialize() {
    
    	$config = config::instance();
    	
    	// first we determine where we're at and from that the host
    	$request_uri = config::request_uri();
    	// but if this magic fails you can manually set the host
    	// config::set('host')->to('example.com');
    	if($config->host == '') $config->host = $_SERVER["HTTP_HOST"];
    	
    	// an attempt to find the name of the index file
    	preg_match("|([a-z,A-Z,_,\.]*)\.php|", $_SERVER["SCRIPT_NAME"], $matches);
    	$config->index_file = $matches[0];
    	
    	// an attempt to see if the app runs at the root of the domain or in a subfolder
		$folder_path = str_replace($config->index_file, '', $_SERVER["SCRIPT_NAME"]);
		$config->folder_path = $folder_path;
		
	    if($folder_path != '/') {
	  		$request_uri = str_replace($folder_path, '', $request_uri);
		}
		
		// protocol determination
    	if ($config->protocol == '') {
			$config->protocol = 'http' . ((isset($_SERVER['HTTPS']) && $_SERVER['HTTPS'] == 'on') ? 's' : '');
    	}
		
		// the base_uri contains the host and the folder where the app is running
		if ($config->base_uri == '') {
			$config->base_uri = $config->protocol.'://'.$config->host . $folder_path;
		} else {
			$config->base_uri = $config->protocol.'://'.$config->base_uri;
		}
		
		// if rewrite is true then we remove the name of the index file from links
		// generated by Raster
		if (config::get('rewrite') == true) {
			$config->link_uri = $config->base_uri;
		} else {
			$config->link_uri = $config->base_uri.$config->index_file."/";
		}
		
		// this is used to retrieve url params passed as key value pairs
		$path_info = str_replace($config->index_file.'/', '', $request_uri);
		$config->uri_segments = explode("/",$path_info);
		array_shift($config->uri_segments);
		
		// forgot what this is but i think its important
		// ah, probably to config::get('uri_string') so you know where in the app you're at
		$config->uri_string = $request_uri;

		// determining what type of environment this runs on
		$config->set_environment(  );
		
		return $config;
	}

	// the set_environment method looks up the current domain in the servers config
	// and when it finds a match it sets the environment accortdingly
	// The environment is very important for database connections for example
	private function set_environment(  ) {
		$this->environment = 'development';
		if( !file_exists(APPBASE.'config/servers.php') ) {
			return $this;
		}
		require_once APPBASE.'config/servers.php';
		
		$this->servers = $servers;

		foreach ((array)$servers as $key => $environment) {
			if(preg_match("|".$key."|", $this->base_uri)) {
				$this->environment = $environment;
			}
		}
		return $this;
	}
	
	// some code i've stolen to detect automatically and safely and always where
	// is the app running
	static function request_uri() {
		if (isset($_SERVER['REQUEST_URI'])) {
			$uri = $_SERVER['REQUEST_URI'];
		}
		else {
			if (isset($_SERVER['argv'])) {
				$uri = $_SERVER['SCRIPT_NAME'] . '?' . $_SERVER['argv'][0];
			}
			elseif (isset($_SERVER['QUERY_STRING'])) {
				$uri = $_SERVER['SCRIPT_NAME'] . '?' . $_SERVER['QUERY_STRING'];
			}
			else {
				$uri = $_SERVER['SCRIPT_NAME'];
			}
		}
		$uri = '/' . ltrim($uri, '/');
		
		return $uri;
	}
	
	// config::get('whatever')
	static function get($varname) {
		$config = config::instance();
		return $config->$varname;
	}
	
	// generic setter as PHP lets us do
	public function __set($name, $value) {
		$this->config[$name] = $value;
	}

	// generic getter as PHP lets us do
	public function __get($name) {
		if (array_key_exists($name, $this->config)) {
			return $this->config[$name];
		}
		return null;
	}
	
	// the singleton instance
    public static function instance()
    {
        $cls = __CLASS__;
        if( class_exists('the_' . $cls) ) $cls = 'the_' . $cls;
        if (!isset(self::$instances[$cls])) {
            self::$instances[$cls] = new $cls;
        }
        return self::$instances[$cls];
    }

}

// Next source to read: ```/system/config/events.php```