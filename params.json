{"name":"Raster","tagline":"A framework that makes happy developers happier","body":"Raster\r\n======\r\n\r\n# Hi i'm Raster!\r\n\r\nSo here's the story from A to Z, you wanna get with me, you gotta listen carefully.\r\n\r\n## Basics\r\n\r\nOpa MVC style! Oops \\o/ wrong song. \r\n\r\nYou've got views in HTML. All HTML and nothing else. All templating is done via HTML comments. Clear?\r\n\r\n> Comments! Why? Because its lovely not to mess around with the finely built work of a front end developer by adding non semantic stuff, ruining tags by breaking them in loops and also its great to see things in the browser as they're meant to be without accolades or php code artifacts killing your retina.\r\n\r\nYou've got models in PHP. Nothing but PHP. All the models return   just data like arrays, strings and booleans.\r\n\r\nYou've got one single thin controller. Anorexic thin. All it  does is controlling: routing and mapping models to views. \r\n\r\n## How it works\r\n\r\n1. You make a nice html page of how you want the UI to look.\r\n\r\n~~~\r\n<html>\r\n\t...\r\n\t<ul class='vehicles'>\r\n\t\t<li>Volvo</li>\r\n\t\t<li>Mercedes</li>\r\n\t\t<li>WV</li>\r\n\t\t<li>Audi</li>\r\n\t</ul>\r\n</html>\r\n~~~\r\n\r\n2. You open that html look at its parts (you know HTML is structured right?) and start thinking about one thing: where does the data come from? And always answer the same thing: from a model.\r\n\r\n~~~\r\n<html>\r\n\t...\r\n\t<!-- the vehicles list comes from the vehicles model! -->\r\n\t<ul class='vehicles'>\r\n\t\t<li>Volvo</li>\r\n\t\t<li>Mercedes</li>\r\n\t\t<li>WV</li>\r\n\t\t<li>Audi</li>\r\n\t</ul>\r\n\t<!-- amaizing! -->\r\n</html>\r\n~~~\r\n\r\n3. You make that model and you code in the logic to get the data then you return it.\r\n\r\n~~~\r\n<?php\r\nclass vehicles {\r\n\r\n\tfunction thelist {\r\n\t\treturn array (\r\n\t\t\tarray('name' => 'Aeroplane'),\r\n\t\t\tarray('name' => 'Rickshaw'),\r\n\t\t\tarray('name' => 'Train'),\r\n\t\t\tarray('name' => 'Bicycle'),\r\n\t\t);\r\n\t}\r\n}\r\n~~~\r\n\r\n4. You go to the html file and code in the comment to output the data.\r\n\r\n~~~\r\n<html>\r\n\t...\r\n\t<!-- render.vehicles.thelist -->\r\n\t<ul class='vehicles'>\r\n\t\t<li><!-- print.name -->Volvo<!-- /print.name --></li>\r\n\t\t<!-- remove -->\r\n\t\t<li>Mercedes</li>\r\n\t\t<li>WV</li>\r\n\t\t<li>Audi</li>\r\n\t\t<!-- /remove -->\r\n\t</ul>\r\n\t<!-- /render.vehicles.thelist -->\r\n</html>\r\n~~~\r\n\r\n5. I wanna really, really, really wanna zigazig ah\r\n\r\n~~~\r\n<html>\r\n\t...\r\n\t<ul class='vehicles'>\r\n\t\t<li>Aeroplane</li>\r\n\t\t<li>Rickshaw</li>\r\n\t\t<li>Train</li>\r\n\t\t<li>Bicycle</li>\r\n\t</ul>\r\n</html>\r\n~~~\r\n\r\n### Now don't go wasting my precious time\r\n\r\nYou've got two primary kind of comments: print and render. Print will only output the result of the model's work. Render will loop trough an array of items returned by the model's work. \r\n\r\n> If the model returns false the the html in the template remains intact.\r\n\r\nYou've got some secondary kind of comments: remove, res and dry. Remove is used to wipe out lorem ipsum and other nonsense. Res specifies a reusable part of a template. Dry specifies a DRY operation: take something from somewhere else and DRY.\r\n\r\nGet your act together we could be just fine.\r\n\r\n## Environment\r\n\r\n> I won't be hasty, I'll give you a try, If you really bug me then I'll say goodbye\r\n\r\nFirst, just in case, in the application's index.php you can set the name of the folder where your application lives:\r\n\r\n~~~\r\n<?php\r\n\r\nrequire_once 'system/boot.php';\r\nboot::$appname = 'application'; // <- here! here!\r\nboot::up();\r\n\r\n?>\r\n~~~\r\n\r\n## The core classes\r\n\r\nWe got Em in the place who likes it in your face.\r\n\r\n### Boot up!\r\n\r\nThe Boot class initialises the global configuration, detects where the files are on the filesystem and also takes care to load your precious configuration and extended or replaced core classes.\r\n\r\nYou got G like MC who likes it on a...\r\n\r\n### Events are awesome!\r\n\r\nWhat does it Em like it on? I could never figure it out man.\r\nBut the Events class glues together all the wonderful singletons Raster is made of. For example, the default events are in /system/config/events.php:\r\n\r\n~~~\r\n<?php\r\nevent::bind('launch')->to('controller','respond')->core();\r\nevent::bind('route_found')->to('controller','handle_response')->core();\r\nevent::bind('done')->to('controller','output')->core();\r\n?>\r\n~~~\r\n\r\nEasy V doesn't come for free, she's a real lady\r\n\r\n### Configuration is a global object in your app\r\n\r\nTo configure a Raster application you create files in your config directory of your application and issue directives such as:\r\n\r\n~~~\r\n<?php\r\nconfig::set('theme')->to('roses');\r\n?>\r\n~~~\r\n\r\nthen it will be available as:\r\n\r\n~~~\r\n<?php\r\n$valentinesday = config::get('theme');\r\n?>\r\n~~~\r\n\r\nAnd as for me, ha you'll see\r\n\r\n### I'm utility\r\n\r\nThe Utility class has some methods that help you while developing with Raster such as getting url parameters, detecting if you have or not post/get data and so forth. Its very useful in models where you can for example not continue the method if there is no data passed to it:\r\n\r\n~~~\r\n<?php\r\n\t...\r\n\tfunction save_user() {\r\n\t\tif(util::no_post_data()) return false;\r\n\t}\r\n?>\r\n~~~\r\n\r\n## Oh yes, Database\r\n\r\nIf you wanna be my lover, you gotta get with my friends.\r\n\r\nMy friend is [Red Bean](http://www.redbeanphp.com). Its a nice ORM that handles table creation and mapping of database data to PHP objects. Its my friend because its rock solid, fast, configurable and i was too damn lazy to write database adapters and whatnot.\r\n\r\n## Oh, oh and automatic form management\r\n\r\nRaster handles forms automatically because the templating class has this awesome method called _form_state_.\r\n\r\n~~~\r\n<?php\r\nclass users {\r\n\t...\r\n\tfunction add_or_edit_user() {\r\n\t\t\r\n\t\t$page = template::instance();\t\r\n\t\t$db = database::instance();\r\n\r\n\t\t$uid = util::param('id', false);\r\n\t\tif(!$uid) return false;\t\t\r\n\r\n\t\t$user = $db->get_user_by_id($uid);\r\n\t\treturn $page->form_state($user);\r\n\t}\r\n}\r\n?>\r\n~~~\r\n\r\nThat code above will handle autocompletion of _value_ attributes and _selected_ attributes by matching the _name_ of the form fields to the keys of the $user array. In your template you'll have:\r\n\r\n~~~\r\n<!-- render.users.add_or_edit_user -->\r\n<form>\r\n\t<input type='text' name='username' />\r\n</form>\r\n<!-- /render.users.add_or_edit_user -->\r\n~~~\r\n\r\nAnd for all this convenience all you have to remember is to put type before name in the html :)\r\n\r\nSlam your body down and wind it all around!\r\n\r\n## Aaaaaand Fork!\r\n\r\nIf you wanna be my lover, you have got to give\r\nTaking is too easy, but that's the way it is.\r\n\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}